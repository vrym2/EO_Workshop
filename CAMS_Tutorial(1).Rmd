---
title: "CAMS Air Quality Data Tutorial"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

In this tutorial we'll download, visualise and analyse air quality data from The Copernicus Atmosphere Modelling Service (CAMS), implemented for the EU by the European Centre for Medium-Range Weather Forecasts (ECMWF).  CAMS is a dataset generated by satellite and ground-based observations with an ensemble of atmospheric forecast models.  You can read about CAMS and ECMWF here: https://www.ecmwf.int/en/about/what-we-do/environmental-services/copernicus-atmosphere-monitoring-service .  We'll also gain experience working with a data format important for atmospheric data science, netCDF.

Before starting this tutorial, set up an account to access the CAMS service at this website:  https://ads.atmosphere.copernicus.eu/user/login?destination=/ .  DO NOT tick the box to register as an organisation.  Just register an account for yourself as an individual.

This tutorial can be followed in its R markdown file format, which can be opened in Rstudio which allows you to run code chunks as they are to see the outputs, or easily modify them and run them again.  Alternatively, you can work from the HTML document and type the code in full yourself.

# Downloading Data

Once you have created an account and logged in, click on the Datasets tab or go to https://ads.atmosphere.copernicus.eu/cdsapp#!/search?type=dataset .  Look at the titles and descriptions of the different CAMS datasets.  As with other model datasets, forecast data will have been generated directly by the models, and can be run for future time periods.  Reanalysis data are processed after the time period of the model run and combined with observations to improve the accuracy of the data.

Click on a few of the datasets and have a quick look at the information on the Overview tab.  Note there is also a Documentation tab with links to detailed information on each dataset.

Go to the "CAMS global reanalysis (EAC4) monthly averaged fields" dataset.  When you use this dataset, you should cite it as Inness et al. (2019), http://www.atmos-chem-phys.net/19/3515/2019 .  Read the Overview tab, then navigate to the Dowload data tab.

Under Variable, click the arrow next to "Single level" so you can see all the single value variables.  This means that there is one number for each of these variables in a given grid square, for example column NO2, rather than being vertically resolved, like temperature.

Tick the box next to "Particulate matter d < 2.5 Âµm (PM2.5)" and the box next to "Total column nitrogen dioxide".  Do not select any multi-level products and scroll down to the bottom of the page.  For Year select 2019 and for Month select all.  Under Product select "Monthly Mean".  Under Area, select "Restricted Area" and enter a latitude range from 30 degrees to 60 degrees and a longitude range from -10 to 30.  Under Format select "NetCDF (experimental)".  Review and accept the terms and conditions, and then press the "Submit Form" button at the bottom of the page.

You will be directed to a page called "Your Requests".  It will take a little while for the dataset to be generated.  Then press the "Download" button.  Move the file to your R working directory, and rename it to "CAMS_data.nc".

# NetCDF and the ncdf4 Package

NetCDF is an important data format for atmospheric science.  In R, the recommended package for working with data in this format is the ncdf4 package.  If you do not have this package installed do that now.

### Exploring NetCDF Files

Now let's have a look at our netCDF file.  We can use the nc_open command to read in information about our netCDF file.

```{r}
#load the ncdf4 library
library(ncdf4)
#first, use nc_open to have a look at the file description
nc_open('CAMS_data.nc')
#then, write the file description to a list
#we'll call this "nc"
nc<-nc_open('CAMS_data.nc')
```

This gave us detailed information describing the datafile.  If you would like to save the dataset information to a text file, you can do that as follows.

```{r}
# Save the print(nc) dump to a text file (same name as the nc file with a txt extension)
{
    sink("CAMS_data.txt")
    print(nc)
    sink()
}
```

If you open that text file from R studio, you can keep it open in a tab next to your markdown script so you can refer to it as we proceed.

Let's have a look at some key attributes of the data.  NetCDF files usually have clear information about the variables and dimensions, which is very helpful when working with a data source that is new to us.  We can see the information in the list above or the text file you generated, or we can ask R to give us the specific information we seek.  Using attributes we can find the names of all the variables,

```{r}
attributes(nc$var)$names
```

and then for each of these we can read other attributes, here, for example, the long name of the the variable.  The output "hasatt" is TRUE if the named attribute was found, and FALSE otherwise, and "value" is the value of the attribute you queried.

```{r}
ncatt_get(nc, "pm2p5", attname="long_name")
ncatt_get(nc, "tcno2", attname="long_name")
```


We can also find the names of the dimensions.

```{r}
attributes(nc$dim)$names
```


###Reading in Variables and Dimensions

So we have two variables (pm2p5 and tcno2) and three dimensions (longitude, latitude and time).  Now retrieve a matrix of the PM2.5 data using the ncvar_get function and write it to a data frame called pm25, and do the same for nitrogen dioxide, calling it no2.


```{r}
# The [1] in brackets designates that the first variable data are retrieved, and from the order of names we know PM2.5 is the first variable in the file.
pm25 <- ncvar_get(nc, attributes(nc$var)$names[1])
# Print the data's dimensions
dim(pm25)

# Then do the same for NO2 by changing the [1] to [2], and writing it to no2
no2 <- ncvar_get(nc, attributes(nc$var)$names[2])
# Print the data's dimensions
dim(no2)

```

R expects array fill values and missing data to show up as NA.  The data we are working with may not use the same convention.  We can use ncatt_get to look at this attribute to find the fill/missing value indicator in our data frame and replace it with NA.  

```{r}
#Find the fill and missing values for the two variables.
ncatt_get(nc,'pm2p5',"_FillValue")
ncatt_get(nc,'pm2p5',"missing_value")
ncatt_get(nc,'tcno2',"_FillValue")
ncatt_get(nc,'tcno2',"missing_value")
```


For this CAMS data the fill value and missing data value are the same (-32767), so we only need to do this once, but we need to do it for each variable.

```{r}
#change the netcdf fill value to NA for R
#note that for these CAMS data the fill value and missing data indicator value are the same
fillvalue1 <- ncatt_get(nc,'pm2p5',"_FillValue")
pm25[pm25==fillvalue1$value] <- NA

fillvalue2 <- ncatt_get(nc,'tcno2',"_FillValue")
no2[no2==fillvalue2$value] <- NA
```

Let's read the dimension data into vectors, and store their units and their lengths.

```{r}
lon <- ncvar_get(nc,"longitude")
lonunits <- ncatt_get(nc,"longitude","units")
nlon <- dim(lon)

lat <- ncvar_get(nc,"latitude")
latunits <- ncatt_get(nc,"latitude","units")
nlat <- dim(lat)

time <- ncvar_get(nc,"time")
tunits <- ncatt_get(nc,"time","units")
ntime <- dim(time)
```


###Working with Time Dimensions

Understanding and working with dates in netCDF can take a little getting used to.  Their are a number of ways date information is reflected and it is critical you look at the units.  Instead of having dates in a day month year format like you might use in a spreadsheet, in large atmospheric datasets they are typically recorded as numbers.  If we display the tunits we just read in, we can see the time units for this dataset.

```{r}
tunits
```

We see that the time units are hours since 12AM on the 1st of January, 1900.  If we want to generate date strings for tracking our analysis and plotting, we can use as.Date.  Since we are working with monthly average data, we can work in days, as follows, and have a look at the first days of the month for each of the 12 months we are working with here.

```{r}
dates<-as.Date(time/24, origin = "1900-01-01")
dates
```


# Plotting CAMS Data on Maps

Okay, we have imported the data and sorted the dimensions.  Now let's plot it on a map.  A simple and flexible map for borders can be generated with the rnaturalearth library.  We'll pull in polygons of the map and assign them to a spatial polygons dataframe which we'll call world.  Feel free to try other mapping and plotting approaches if you would like to experiment further with visualisation, for example by generating a raster file from the data and using leaflet to make an interactive map.

```{r}
library("rnaturalearth")
library("rnaturalearthdata")
world <- ne_countries(scale = "medium")
#if you would like to see what the map looks like, you could plot(world)
#note this is class(world)
```

###Plot NO2 Data

Now we'll use levelplot to plot NO2 column data from an individual month and add the map as a layer.  We'll use the variable timestep to specify which month we would like to plot, and start with the first month.

```{r}
# levelplot of the slice
library(lattice)
library(sp)
library(maps)
timestep<-1
grid <- expand.grid(lon=lon, lat=lat)
levelplot(no2[,,timestep] ~ lon * lat, data=grid, cuts=11, pretty=T, main = c("CAMS EAC4 monthly averaged total column NO2",as.character(dates[timestep]))) + latticeExtra::layer(sp.polygons(world))


#Further manipulation of the color scale is possible, for example using the library RColorBrewer.
```


###Question

Can you identify the sources of the two hotspots appearing on this map?

###Plot PM2.5 Data for the same month.

```{r}
grid <- expand.grid(lon=lon, lat=lat)
levelplot(pm25[,,timestep] ~ lon * lat, data=grid, cuts=11, pretty=T, main = c("CAMS EAC4 monthly averaged PM2.5",as.character(dates[timestep]))) + latticeExtra::layer(sp.polygons(world))
```

### Question

Can you figure out how to read in the units for one or both of these variables and display them next to the colorbar?


# Manipulating Data

For taking a quick look at some data, it is perfectly fine to read in and plot data from individual time steps.  However, if we are working with larger datasets and want to analyse it, it is much more efficient to work with data frames, moving us from 3D arrays (lon x lat x time) into 2D matrices.  Now we'll create data frames with the data for each variable.  First, let's reshape the spatial dimension data.


```{r}
#reshape spatial dimension data into data frame
lonlat<-as.matrix(expand.grid(lon,lat))
dim(lonlat)
```

This is now an array with two columns with 2214 elements, the first contains the longitude coordinate and the second the latitude.  Now transform no2 data for the first timestep into a vector.  This will produce a vector with the same number of elements.

```{r}
#vector of no2 values
no2Vector<-as.vector(no2[,,timestep])
length(no2Vector)
```

Now we can incorporate these into a data frame.

```{r}
no2_df01<-data.frame(cbind(lonlat,no2Vector))
names(no2_df01) <- c("lon","lat","NO2")
#display the first 5 rows of the data frame
head(na.omit(no2_df01),5)
```


If we want, we can write these data to a csv file for later analysis.

```{r}
#write this to a csv file
write.table(na.omit(no2_df01),"no2_df01.csv", row.names=FALSE, sep=",")
```


We can plot directly from this dataframe by modifying the above code.

```{r}
levelplot(no2_df01[,3] ~ no2_df01[,1] *no2_df01[,2] , data=grid, cuts=11, pretty=T, main = c("CAMS EAC4 monthly averaged total column NO2",as.character(dates[timestep]))) + latticeExtra::layer(sp.polygons(world))
```

Finally, we want to pull in the data from all the time steps into one data frame.  Create a long vector.
```{r}
no2_vec_long <- as.vector(no2)
length(no2_vec_long)
```
Then reshape into a matrix, using the dimension lengths nlon, nlat and ntime that we assigned before.  Use dim() to check the dimensions of the matrix.

```{r}
no2_mat <- matrix(no2_vec_long, nrow=nlon*nlat, ncol=ntime)
dim(no2_mat)
```

Have a look at the top of the matrix.
```{r}
head(na.omit(no2_mat))
```


Now create a dataframe.

```{r}
lonlat<-as.matrix(expand.grid(lon,lat))
no2_df<-data.frame(cbind(lonlat, no2_mat))
names(no2_df)<-c("lon","lat",as.character(dates[1]),as.character(dates[2]),as.character(dates[3]),as.character(dates[4]),as.character(dates[5]),as.character(dates[6]),as.character(dates[7]),as.character(dates[8]),as.character(dates[9]),as.character(dates[10]),as.character(dates[11]),as.character(dates[12]))

head(na.omit(no2_df))
```


### Question

Can you find our from the CAMS documentation whether the lat lon pairs indicate the centre or a corner of the pixel they register?

### Question

Can you find a simpler way to name the dataframe time columns?

# Analysing the Data

Calculate the mean NO2 and max NO2 for each pixel and append them as new columns to the data frame.  Note that each time you run this you'll add more columns to the data.

```{r}
no2_df$mean <-apply(no2_df[3:14],1,mean)
no2_df$maximum <-apply(no2_df[3:14],1,max)
head(na.omit(no2_df))
```

### Write the dataframe to a csv

```{r}
#write this to a csv file
write.table(na.omit(no2_df),"no2_df01.csv", row.names=FALSE, sep=",")
```

### Plot the Annual Mean NO2 for 2019

```{r}
levelplot(no2_df[,15] ~ no2_df[,1] *no2_df[,2] , data=grid, cuts=11, pretty=T, main = c("CAMS EAC4 annual average total column NO2",as.character(dates[timestep]))) + latticeExtra::layer(sp.polygons(world))
```

### Question

Can you now plot the maximum?

### Practice

Do the same for PM2.5

### Time Series

Choose two grid squares and plot time time series for the year.

```{r}

```


### Question

Can you find a systematic approach for identifying the grid squares for cities you are interested in analysing?

# Extension Activities

1) plot monthly point measurements from airbase stations
2) download high temporal resolution dataset, work with 3-hourly data
3) extract time series from grid squares of two cities
4) do some seasonality analysis--can you utilise any of the openair tools?
5) create a netCDF of analysed data, write a new variable to the existing netCDF




# Resources

A "NetCDF in R" Cheatsheet https://www.r-bloggers.com/2016/08/a-netcdf-4-in-r-cheatsheet/

netcdf in R, from R for Earth-System Science
https://pjbartlein.github.io/REarthSysSci/netCDF.html

Inness et al. (2019), http://www.atmos-chem-phys.net/19/3515/2019


